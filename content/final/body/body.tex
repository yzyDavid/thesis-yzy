\cleardoublestylepage{common}

\section{正文}

\subsection{目标}

本部分描述本设计所开发的系统的功能与目的。

\subsection{开发技术}

本部分列出工程实现上所依赖的全部技术。

golang v1.11.5

GoLand

Kubernetes v1.14

minikube 1.0.0

operator-framework v1.0.0

\subsection{工程背景}

本部分将会论述为了实现本系统，依赖的开源组件与开源解决方案等。

\subsection{实现方式}

本部分将会详细讲解本人实现此系统的详细过程。

\subsection{算法描述}

本部分讨论在不涉及系统实现的细节前提下，调度算法的背景，意义与实现。

\subsubsection{背景}

本部分讨论一个通用的调度算法需要考虑哪些内容。

我们先思考一下，一个通用的应用程序运行需要依赖哪些资源。资源总共分为软件资源和硬件资源两类。软件资源包括操作系统版本，动态链接库依赖等，这里不在我们的主要讨论范围之内，暂时不考虑。硬件资源包括计算资源，即处理器时间；存储资源，包括主存储器，外置存储器如硬盘容量；网络带宽；异构计算设备，包括，型号，类型，使用率等等限制。

这里定义我们的调度算法为，在软件资源依赖能满足的前提下，将不同的多租户应用部分编排至不同的应用与机器，并保证满足各个租户业务与数据的资源声明得到满足。

为了满足这些资源限定，一个通用的算法需要对可能出现的所有资源类型进行分类，才能从更抽象的角度进行考虑。因为我们无法枚举可能出现的一切资源类型。

一切资源限度要求，都可以用一个标量来描述。如 CPU 计算资源需求，可以将单位核数输出的计算力定义为一个定值，假设就是 100，那么每个应用对 CPU 计算能力的要求就可以使用一个数值来描述了。抽象来讲，即是一个标量加上任意自定义的单位即可描述。

然而考虑到计算资源横向扩展的要求，资源的种类又需要做出区分。考虑内存消耗，对于深度学习模型而言，内存消耗主要是模型加载至内存中，每一台运行服务的服务器都需要消耗等量的内存。再考虑计算资源消耗，对于稳定相同的计算任务或者流量，消耗的总计算力之和不变，横向扩展后新增的服务器不需要额外浪费计算力，而是负担了原有服务器不能承担的一部分任务。我们将前一种横向扩展后每台服务器都要消耗等量的资源称为硬性资源，后一种可以被横向扩展利用的资源称为弹性资源。在绝大多数场景下，如此划分资源就可以描述弹性调度场景下资源的消耗量。

到此为止，我们已经得到了一个通用调度算法的定义，即具有多种资源约束，资源约束都被归类至硬性资源和弹性资源其中之一，同时满足。下文我们开始讨论常用的优化算法，并着重考虑他们在我们场景下的使用方式。

\subsubsection{分析}

在这个背景下，调度算法可以处理如下问题：

有 $N$ 个业务，或称租户，模型，下面统称模型，记为 $Model_1,Model_2,...,Model_N$。每个模型都需要 $a$ 个硬性资源 $Rfix_1,Rfix_2,...,Rfix_a$，$b$ 个弹性资源 $Relastic_1,Relastic_2,...,Relastic_b$。我们还有 $M$ 种机器类型，每种机器类型也需要给出上述硬性资源和弹性资源的提供量 $Rfix_1,Rfix_2,...,Rfix_a,Relastic_1,Relastic_2,...,Relastic_b$。

我们需要给出 $d$ 个部署信息，记为 $Deployment_1,Deployment_2,...,Deployment_d$，每个部署信息包括了其所包含的模型列表以及需要的机器个数，即模型列表和副本数组成的二元组：$([Model_x,Model_y,...,Model_{last}],Replicas)$。

\subsubsection{贪心算法}

贪心算法是一类算法思想的统称，指每一步都选择当前一步考虑范围内的最优解，最终得到的解就是全剧最优解的一类算法。如果放宽条件，广义的贪心算法也就指每一步都选择考虑范围内的最优解的算法。因为在足够复杂的场景内，我们不一定能给出一个调度问题的全局最优解，我们这里的所采用的贪心策略，将使用后一种广义的定义。

\subsubsection{背包问题}

\subsubsection{结论}

\subsection{效果对比}

\subsubsection{资源利用率}

\subsubsection{容灾能力}

