\cleardoublestylepage{common}

\section{正文}

\subsection{目标}

本部分描述本设计所开发的系统的功能与目的。

\subsection{开发技术}

本部分列出工程实现上所依赖的全部技术。

golang v1.11.5

GoLand

Kubernetes v1.14

minikube 1.0.0

operator-framework v1.0.0

\subsection{工程背景}

本部分将会论述为了实现本系统，依赖的开源组件与开源解决方案等。

\subsection{实现方式}

本部分将会详细讲解本人实现此系统的详细过程。

\subsection{算法描述}

本部分讨论在不涉及系统实现的细节前提下，调度算法的背景，意义与实现。

\subsubsection{背景}

本部分讨论一个通用的调度算法需要考虑哪些内容。

我们先思考一下，一个通用的应用程序运行需要依赖哪些资源。资源总共分为软件资源和硬件资源两类。软件资源包括操作系统版本，动态链接库依赖等，这里不在我们的主要讨论范围之内，暂时不考虑。硬件资源包括计算资源，即处理器时间；存储资源，包括主存储器，外置存储器如硬盘容量；网络带宽；异构计算设备，包括，型号，类型，使用率等等限制。

这里定义我们的调度算法为，在软件资源依赖能满足的前提下，将不同的多租户应用部分编排至不同的应用与机器，并保证满足各个租户业务与数据的资源声明得到满足。

为了满足这些资源限定，一个通用的算法需要对可能出现的所有资源类型进行分类，才能从更抽象的角度进行考虑。因为我们无法枚举可能出现的一切资源类型。

一切资源限度要求，都可以用一个标量来描述。如 CPU 计算资源需求，可以将单位核数输出的计算力定义为一个定值，假设就是 100，那么每个应用对 CPU 计算能力的要求就可以使用一个数值来描述了。抽象来讲，即是一个标量加上任意自定义的单位即可描述。

然而考虑到计算资源横向扩展的要求，资源的种类又需要做出区分。考虑内存消耗，对于深度学习模型而言，内存消耗主要是模型加载至内存中，每一台运行服务的服务器都需要消耗等量的内存。再考虑计算资源消耗，对于稳定相同的计算任务或者流量，消耗的总计算力之和不变，横向扩展后新增的服务器不需要额外浪费计算力，而是负担了原有服务器不能承担的一部分任务。我们将前一种横向扩展后每台服务器都要消耗等量的资源称为硬性资源，后一种可以被横向扩展利用的资源称为弹性资源。在绝大多数场景下，如此划分资源就可以描述弹性调度场景下资源的消耗量。

\subsubsection{贪心算法}

\subsubsection{背包问题}

\subsection{效果对比}

\subsubsection{资源利用率}

\subsubsection{容灾能力}

